<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="favicon.ico">
  <meta name="keyword" content="„Éà„Éû„ÉÜ„Ç£„Éº„Éä,XYM,Symbol">
	<meta meta name="description" content="„Éà„Éû„ÉÜ„Ç£„Éº„Éä Monitor„ÅØxembook.tomato„É¢„Ç∂„Ç§„ÇØ„ÅÆ„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÇíÂèØË¶ñÂåñ„Åô„Çã„ÉÑ„Éº„É´„Åß„Åô">
	<link rel="canonical" href="https://ishidad2.github.io/2022-tomatina">
	<meta name="twitter:card" content="summary">
	<meta name="twitter:site" content="@ishidad2">
	<meta name="twitter:title" content="„Éà„Éû„ÉÜ„Ç£„Éº„Éä Monitor">
	<meta name="twitter:description" content="„Éà„Éû„ÉÜ„Ç£„Éº„Éä Monitor„ÅØxembook.tomato„É¢„Ç∂„Ç§„ÇØ„ÅÆ„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÇíÂèØË¶ñÂåñ„Åô„Çã„ÉÑ„Éº„É´„Åß„Åô">
	<meta name="twitter:image" content="https://ishidad2.github.io/2022-tomatina/tomato.png">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <title>„Éà„Éû„ÉÜ„Ç£„Éº„Éä Monitor</title>
</head>
<body>
  <header>
    <h1>„Éà„Éû„ÉÜ„Ç£„Éº„Éä Monitor</h1>
  </header>
  <section>
    <div class="container-fluid">
      <div class="row">
        <div class="col col-sm-12 col-md-11 col-lg-8">
          <div class="date-area">
            üçÖ„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Ç∞„É©„Éï (<span id="tomato_graph_update"></span> Êõ¥Êñ∞)
          </div>
          <canvas id="myChart" height="120"></canvas>
        </div>
        <div class="col">
          <div class="date-area">
            XEMBooküçÖ„É©„É≥„Ç≠„É≥„Ç∞ (<span id="ranking_update"></span> Êõ¥Êñ∞)
          </div>
          <div class="ranking">
            <div id=""loading></div>
            <ul id="tomatoRanking">
            </ul>
          </div>
        </div>
        <!-- col end -->
      </div>
      <!-- row end -->
    </div>
  </section>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <script src="https://xembook.github.io/nem2-browserify/symbol-sdk-pack-2.0.0.js"></script>
  <script src="https://ishidad2.github.io/symbol-node-util-browserify/symbol-node-util-1.0.9.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.js" integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/dayjs@1.8.21/dayjs.min.js"></script>
  <script>
    const { getActiveNode } = require("/node_modules/symbol-node-util");
    const {
      NetworkType,
      RepositoryFactoryHttp,
      MosaicId,
      TransactionGroup,
      Listener,
      ReceiptType,
      TransactionType
    } = require("/node_modules/symbol-sdk");
    (async()=>{
      $('#tomato_graph_update').text(dayjs().format('HH:mm:ss'));

      let myChart;
      let labelVal = [dayjs().format('HH:mm:ss')];
      let tomatoCharCount = 0;
      let toshiTomatoChartCount = 0;
      let pageNumber = 0;
      const maxPage = 25;
      
      // ===== Êú¨Áï™ ====
      const tomatinaMosaicId = "310378C18A140D1B";
      const toshiTomatoMosaicId = "613E6D0FC11F4530";
      const networkType = NetworkType.MAIN_NET;
      const node = await getActiveNode(NetworkType.MAIN_NET);
      const startBlock = 1529793; //https://clock.sfn.tools/symbol?block=1529793&lang=ja
      const endBlock = 1532672;   //https://clock.sfn.tools/symbol?block=1532672&lang=ja

      // ******** „ÉÜ„Çπ„ÉàÁî® ********
      // const tomatinaMosaicId = "224CEE82F56D5A8B";
      // const toshiTomatoMosaicId = "16D70B79689070DB";
      // const networkType = NetworkType.TEST_NET;
      // const node = await getActiveNode(NetworkType.TEST_NET);
      // const startBlock = 619006;
      // const endBlock = 640000;

      console.log("Êé•Á∂ö", node);

      const max = 40;
      const ctx = $('#myChart');

      const repo = new RepositoryFactoryHttp(node);
      const txRepo = repo.createTransactionRepository();
      const nsRepo = repo.createNamespaceRepository();
      const blockRepo = repo.createBlockRepository();

      const epochAdjustment = await repo.getEpochAdjustment().toPromise();
      const wsEndpoint = node.replace('http', 'ws') + "/ws";
      const listener = new Listener(wsEndpoint,nsRepo,WebSocket);

      async function getTransfers(block){
        tomatoCharCount = 0;
        toshiTomatoChartCount = 0;
        try {
          const tx = await txRepo.search({
            height: block.height.compact(),
            group: TransactionGroup.Confirmed
          }).toPromise();
          await parseTxs(tx.data);
        } catch (error) {
          console.error(error);
        }
      }

      async function parseTxs(txs){
        for(tx of txs){
          //„Ç¢„Ç∞„É™„Ç≤„Éº„Éà„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥Âà§ÂÆö
          if(tx.type === TransactionType.AGGREGATE_COMPLETE || tx.type === TransactionType.AGGREGATE_BONDED){
            //„Ç¢„Ç∞„É™„Ç≤„Éº„Éà„ÅÆÂ†¥Âêà„ÄÅÂÜÖÈÉ®„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÇíÂÜçÂèñÂæó
            const reTx = await txRepo.getTransaction(
              tx.transactionInfo.hash,
              TransactionGroup.Confirmed
            ).toPromise();
            console.log("== aggregateTx ==")
            //„Åì„ÅÆÈñ¢Êï∞„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âëº„Å≥Âá∫„Åó
            parseTxs(reTx.innerTransactions);  //ÂÜçÂ∏∞Âëº„Å≥Âá∫„Åó
            console.log("-----------------")
          }else {
            if(tx.mosaics !== undefined){
              tx.mosaics.forEach(mosaic => {
                if(mosaic.id.toHex() === tomatinaMosaicId){
                  console.log("üçÖ„É¢„Ç∂„Ç§„ÇØ„ÅÆTx", tx);
                  tomatoCharCount++;
                }
                if(mosaic.id.toHex() === toshiTomatoMosaicId){
                  console.log("ToshiüçÖ„É¢„Ç∂„Ç§„ÇØ„ÅÆTx", tx);
                  toshiTomatoChartCount++;
                }
              });
            }
          }
        }
      }

      async function updateChart(block){
        if(myChart){
          const blockTime = dayjs((epochAdjustment * 1000) + block.timestamp.compact()).format("HH:mm:ss");
          console.log("blockTime", blockTime);
          let chartLabels = myChart.data.labels;
          let chartDatasets =  myChart.data.datasets;
          if( myChart.data.labels.length > max){
            chartLabels =  myChart.data.labels.slice( myChart.data.labels.length-max,  myChart.data.labels.length)
          }
          //„É©„Éô„É´Êõ∏„ÅçÊèõ„Åà
          myChart.data.labels = [...chartLabels, blockTime];

          await getTransfers(block);

          myChart.data.datasets.forEach((dataset) => {
            if( dataset.data.length > max){
              dataset.data.shift();
            }
            if(dataset.label === "xembook.tomato"){
              dataset.data.push(tomatoCharCount);
            }
            if(dataset.label === "toshi.tomato"){
              dataset.data.push(toshiTomatoChartCount);
            }
          });

          myChart.update();
          $('#tomato_graph_update').text(dayjs().format('HH:mm:ss'));
        }
      }
      
      function drawChart(){
        myChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labelVal,
            datasets: [
              {
                label: 'xembook.tomato',
                data: [0],
                backgroundColor: 'rgba(0, 134, 197, 0.7)',
                borderColor: 'rgba(0, 134, 197, 1)',
                fill: false,
              },
              {
                label: 'toshi.tomato',
                data: [0],
                backgroundColor: 'rgba(255,128,64, 0.7)',
                borderColor: 'rgba(255,128,64, 1)',
                fill: false,
              }
            ]
          },
          options: {
            scales: {
              y: {
                beginAtZero: true
              }
            },
          }
        });
      }

      async function getTomatoTransaction(rank){
        pageNumber++;
        console.log("page", pageNumber);
        let lastHeight = 0;
        const criteria = {
          group: TransactionGroup.Confirmed,
          embedded: true,
          transferMosaicId: new MosaicId(tomatinaMosaicId),
          order: "desc",
          pageNumber: pageNumber
        }
        const txs = await txRepo.search(criteria).toPromise();
        let isLastPage = txs.isLastPage;
        for(tx of txs.data){
          //ÊåáÂÆö„Éñ„É≠„ÉÉ„ÇØÂÜÖ„ÅÆüçÖ„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÇíË®àÊ∏¨
          const block_height = tx.transactionInfo.height.compact();
          if(endBlock >= block_height && startBlock <= block_height){
            rank.push(tx.signer.address.plain());
          }
          lastHeight = tx.transactionInfo.height.compact();
        }
        return [isLastPage, lastHeight];
      }

      function getBatchOfTransfers(){
        pageNumber = 0;
        let rank = [];
        let timer = setInterval( async function(){
          [isLastPage, height] = await getTomatoTransaction(rank);
          console.log("üçÖÂ±•Ê≠¥ÂèñÂæóÈñãÂßã" + dayjs().format(), isLastPage, height);
          if (isLastPage || startBlock >= height || maxPage <= pageNumber){
            let rankings = {};
            for (let i = 0; i < rank.length; i++) {
              var elm = rank[i];
              rankings[elm] = (rankings[elm] || 0) + 1;
            }
            let result = Object.entries(rankings).map(([key, value]) => ({"address": key, "txNum": value}));

            let tomatinaRanking = result.sort(function(a, b){
              return (a.txNum > b.txNum) ? -1 : 1;
            });
            $('#tomatoRanking').empty();
            tomatinaRanking.forEach((el) => {
              console.log(el);
              $('#tomatoRanking').append('<li>' + el.address + " " + el.txNum + '</li>');
            })
            $('#ranking_update').text(dayjs().format('HH:mm:ss'));
            clearInterval(timer);
          }
        },1000);
      }

      drawChart();
      getBatchOfTransfers();
      setInterval( function(){
        getBatchOfTransfers();
      }, 60000 * 3); //3ÂàÜÊØé
      listener.open().then(() => {
        console.log('listner open')
        listener.newBlock().subscribe((block) => {
          updateChart(block);
        });

        listener.webSocket.onclose = function(){
          console.log("listener onclose");
        }
        listenNewBlock();
      });

      function listenNewBlock(){
        listener.newBlock();
        setTimeout(listenNewBlock, 50000);
      }
    })();
  </script>
</body>
</html>